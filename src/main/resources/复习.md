1.分布式幂等性如何设计？

解决方案：
1.查询和删除不在幂等讨论范围内，查询肯定没有幂等的说，删除：第一次删除成功后，后面来删除直接返回0，也是返回成功

2.建唯一索引：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可）

3.token 机制：由于重复点击或者网络重发，或者nginx重发等情况下会导致数据被重复提交。前端在数据提交前要向后端服务的申请token，token放到Redist 或 JVM 内存,token 有效时间。提交后后台校验token，同时删除token，生成新的token返回。redis要用删除操作来判断token，删除成功代表token 校验通过，
如果用select + delete 来校验token ，存在并发问题，不建议使用/

4.悲观锁
select id,name from table_# where id = '##' for update;

悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用（另外还要考虑id 是否为主键，如果id不是主键或者不是InnoDB 存储引擎，那么就会出现锁全表）

5.乐观锁，给数据库表增加一个version字段，可以通过字段判断是否已经被修改了
update table_XXX set name = #name#,version = version + 1 where where version = #version#

6. 分布式锁，比如redis,zookeeper 的分布式锁。单号为Key ,然后给key 设置有效期（防止支付失败后，锁一直不释放），来一个请求使用订单号生成一把锁，业务代码执行完成后再释放锁。
7.   保底方案，先查询是否存在此单，不存在进行支付，存在就直接返回支付结果


2.简单一次完整的HTTP 请求所经历的步骤？
1.DNS 解析（通过访问的域名找出其IP 地址，递归搜索）
2.HTTP请求，当輸入一个请求时，建立一个socket 连接发起TCP 的3 次握手。
如果时HTTPS 请求，会略微有所不同。

3.1 客户端向服务器发送请求命令（一般时GET或 POST 请求）。
客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能是经过多个路由器，通过例句协议查找给定IP地址的MAC 地址，然后发送ARP 请求查找目的地址
如果得到回应后就可以使用ARP 请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

3.2 客户端发送请求头信息和数据

4.1 服务器发送应答头信息
4.2 服务器 向客户端发送数据

5.服务器关闭TCP 连接 （4 次挥手）
这里是否关闭TCP连接，也根据HTTP Keep-Alive 机制有关
同时，客户端也可以主动发起关闭TCP 连接

6.客户端根据返回的HTML，CSS,JS 进行渲染



3.说说你对分布式事务的了解

分布式事务是企业集成中的一个计数难点，也是每一个分布式系统架构都会涉及到的一个东西
特别是再微服务架构中，几乎可以说是无法避免的

ACID 指数据库事务正确执行的四个基本要素：
1.原子性（Atomicity)  2. 一致性（Consistency)  3. 隔离性（isolation） 4. 持久性（Durability)

CAP
CAP 原则又称CAP 定理  ，指的是在一个分布式系统中，一致性（Consistency），可用性（Availability)

分区容忍性（Partition tolerance) .CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

一致性：在分布式系统中的所有数据备份，在同一个时刻是否同样的值
可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
分区容忍性： 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。



package com.hehe;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CyclicBarrier;

@SpringBootTest
class HeheApplicationTests {

    @Test
    void contextLoads() {
//        CyclicBarrier和countDownLatch的区别
//        俩个看上去有点像的类，都在Java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：
//        CycLicBarrier的某个某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达这个点，所有线程才重新运行
//        CountDownLatch则不是，某线程运行到某个点之后，只是给某个数值-1而已，该线程继续运行
//

//        volatile關鍵字作用
//        1）多綫程主要是围绕可见性和原子性两个特性而展开，使用volatile关键字修i是的变量，保证了其在多线程之间的可见性
//        及每次读取到的volatile变量，一定是最新的数据
//        Java代码-> 字节码 -》 根据字节码执行对应的c/C++代码-》c/C++代码被编译成汇编语言-》和硬件电路交互。
//        现实中，为了获取更好的性能jvm可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低代码执行效率

//        从实践角度而言，volatile的一个重要作用就是和CAS结合，保证原子性
//        CyclicBarrier cyclicBarrier = new CyclicBarrier();
//
//        new CopyOnWriteArrayList<>();

    }





//    @Test
//    void threadTest() {
//        new ThreadLocal()
//    }
}


// 软甲设计模式：
//1.创建型模式：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式
//2.结构性模式：适配器模式/装饰器模式，代理模式，外观模式，桥接模式，桥接模式i，组合模式，享元模式
//行为型模式：策略模式,模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式

//并发型模式和线程池模式
/*
* 开闭原则对扩展开放，对修改关闭，在程序需要进行扩展时，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性号，易与维护和升级。想要达到这要实我效果，我们需要使用接口和抽象类。
* 里氏替换原则：面向对象设计的基本原则之一。里氏替换原则说，任何积累可以出现的地方，子类i一定可以出现，LISP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏替换原则是对‘开闭原则；的补充。实现“开闭”原则的关键是抽象化。而基类和子类的继承关系就是抽象化的具体实现，所以历史替换原则是对实现抽象化的具体步骤实现
* 依赖倒转原则  这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体
* 接口隔离原则  使用多个隔离的接口，比使用单个接口要好，这是一个降低类之间耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便，所以上文中多次出现降低依赖，降低耦合
* 迪米特法则,为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立
* 合成复用原则：原则是尽量使用合成/聚合的方式，而不是使用继承
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* */

